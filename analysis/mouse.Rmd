---
title: "Analysis of the RNA-seq data from the epithelial cell population of the mouse mammary gland"
author: "Pedro L. Baldoni"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

# Introduction

In this page, we present the analysis of the epithelial cell population of the mouse mammary gland. The report is divided in two main parts: the analysis of the paired-end data from the basal, luminal progenitor (LP), and mature luminal (ML) cells, and the analysis of the single-end data from the basal and LP cells ([GSE60450](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60450)).

The analysis presented in this report begins with the experimental data already quantified by `Salmon`. Please refer to the script files located in the GitHub repository of this page under the directory path `./code/mouse` which show the commands used to quantify the RNA-seq reads from these experiments. The `targets` files from these experiments are located in `./data/mouse`.

## Setup

We begin this report by setting up some options for rendering this webpage and loading the necessary libraries.

```{r mouse_setup_options}
knitr::opts_chunk$set(
  dev = "png",
  dpi = 300,
  dev.args = list(type = "cairo-png"),
  root.dir = '.'
)
```

```{r mouse_setup_lib,message=FALSE,warning=FALSE}
library(edgeR)
library(data.table)
library(ggplot2)
library(readr)
library(Rsubread)
library(rtracklayer)
library(magrittr)
library(ggpubr)
library(plyr)
library(gplots)
library(grid)
library(ComplexHeatmap)
library(patchwork)
library(tibble)
library(tidyHeatmap)
library(AnnotationHub)
library(sleuth)
library(fishpond)
library(tximeta)
library(tidyverse)
library(SummarizedExperiment)
library(stringr)
library(ragg)
library(kableExtra)
```

Below we load the Ensembl 104 annotation from `AnnotationHub` which is associated to the Ensembl M27 annotation of the mouse mm39 genome.

```{r mouse_setup_anno}
# 'AH95775' annotation corresponds to Ensembl 104 (release M27)
ah <- AnnotationHub()
edb <- ah[['AH95775']]
ensid <- keys(edb)
cols <- c("TXIDVERSION","TXEXTERNALNAME","TXBIOTYPE","GENEIDVERSION",
          "GENENAME","GENEBIOTYPE","ENTREZID")

dt.anno <- select(edb,ensid,cols)
dt.anno <- as.data.table(dt.anno)

dt.anno.gene <- 
  dt.anno[,.(NTranscriptPerGene = .N),
          by = c('GENEIDVERSION','GENEBIOTYPE','ENTREZID','GENENAME')]
dt.anno.gene[,GeneOfInterest := GENEBIOTYPE %in% c('protein_coding','lncRNA')]

dt.anno <- 
  merge(dt.anno,dt.anno.gene[,-c(2,3,4)],by = 'GENEIDVERSION',all.x = TRUE)
```

Paths used in this report are specified below.

```{r mouse_setup_paths}
path.anno <- '../data/annotation/mm39'

path.misc <- file.path('../misc',knitr::current_input())
dir.create(path.misc,recursive = TRUE,showWarnings = FALSE)

path.data.pe <- '../data/mouse/paired-end'
path.quant.pe <- '../output/mouse/paired-end'

path.data.se <- '../data/mouse/single-end'
path.quant.se <- '../output/mouse/single-end'
```

# Analysis of paired-end data

The analysis of paired-end data is divided in two parts. First, we present the analysis at the transcript-level. Second, we present a gene-level analysis. All results discussed in the main paper regarding these experiments are presented in this report.

## Transcript-level analysis

### Data wrangling

The transcript-level analysis starts with some data wrangling.

```{r mouse_data_pe_targets}
dt.targets.pe <- fread(file.path(path.data.pe,'misc/targets.txt'))
dt.targets.pe[,Sample := paste(Group,Replicate,sep = '.')]
dt.targets.pe[,Color := mapvalues(Group,
                                  from = c('Basal','LP','ML'),
                                  to = c('blue','darkgreen','red'))]
setnames(dt.targets.pe,old = 'Group',new = 'group')
dt.targets.pe[,path := 
                file.path(path.quant.pe,'salmon',gsub('_R1.fastq.gz','',File1))]
```

We then load `Salmon`'s output with the function `catchSalmon` from `edgeR` while bringing in some information about the Ensembl M27 annotation.

```{r mouse_data_pe_catch}
catch.pe <- catchSalmon(dt.targets.pe$path,verbose = FALSE)

key.catch.pe.anno <- match(rownames(catch.pe$annotation),dt.anno$TXIDVERSION)

catch.pe$annotation$TranscriptName <- dt.anno$TXEXTERNALNAME[key.catch.pe.anno]
catch.pe$annotation$GeneID <- dt.anno$GENEIDVERSION[key.catch.pe.anno]
catch.pe$annotation$GeneName <- dt.anno$GENENAME[key.catch.pe.anno]
catch.pe$annotation$GeneEntrezID <- dt.anno$ENTREZID[key.catch.pe.anno]
catch.pe$annotation$GeneOfInterest <- dt.anno$GeneOfInterest[key.catch.pe.anno]
catch.pe$annotation$NTranscriptPerGene <- dt.anno$NTranscriptPerGene[key.catch.pe.anno]
catch.pe$annotation$Type <- dt.anno$TXBIOTYPE[key.catch.pe.anno]
```

### Differential transcript expression

#### edgeR with count scaling

First, we assess DTE with the `edgeR` via count scaling pipeline.

```{r mouse_dte_pe_edger-cs}
dte.pe.scaled <- 
  DGEList(counts = catch.pe$counts/catch.pe$annotation$Overdispersion,
          genes = catch.pe$annotation,
          samples = dt.targets.pe)
colnames(dte.pe.scaled) <- dte.pe.scaled$samples$Sample
```

Some basic filtering is done below. We restrict our analyses to protein-coding genes and lncRNA.

```{r mouse_dte_pe_edger-cs_filtering}
keep.pe.scaled <- 
  filterByExpr(dte.pe.scaled) & dte.pe.scaled$genes$GeneOfInterest
dte.pe.scaled.filtr <- dte.pe.scaled[keep.pe.scaled,, keep.lib.sizes = FALSE]
```

Next, we specify the design matrix of our experiment, calculate normalizing factors and estimate the trended negative binomial dispersions.

```{r mouse_dte_pe_edger-cs_norm-disp}
design.pe <- model.matrix(~0+group,data = dte.pe.scaled.filtr$samples)
dte.pe.scaled.filtr <- calcNormFactors(dte.pe.scaled.filtr)
dte.pe.scaled.filtr <- estimateDisp(dte.pe.scaled.filtr,design.pe,robust = TRUE)
```

We proceed with the QL pipeline from `edgeR` by first calling `glmQLFit` and then running QL tests with `glmQLFTest`.

```{r mouse_dte_pe_edger-cs_fit}
fit.pe.scaled <- glmQLFit(dte.pe.scaled.filtr,design.pe,robust = TRUE)

con.LPvsB <- makeContrasts(LPvsB = groupLP - groupBasal,levels = design.pe)
con.MLvsLP <- makeContrasts(MLvsLP = groupML - groupLP,levels = design.pe)

qlf.pe.LPvsB.scaled <- glmQLFTest(fit.pe.scaled,contrast = con.LPvsB)
qlf.pe.MLvsLP.scaled <- glmQLFTest(fit.pe.scaled,contrast = con.MLvsLP)

out.pe.LPvsB.scaled <- topTags(qlf.pe.LPvsB.scaled,n = Inf)
out.pe.MLvsLP.scaled <- topTags(qlf.pe.MLvsLP.scaled,n = Inf)

summary(decideTests(qlf.pe.LPvsB.scaled))
summary(decideTests(qlf.pe.MLvsLP.scaled))
```

#### edgeR with raw counts

Next, we run the `edgeR` pipeline with raw counts without deflating counts by their associated mapping ambiguity overdispersion. The pipeline is similar to the one used with scaled counts, and the only difference is regarding count deflation which is now absent.

```{r mouse_dte_pe_edger-rc}
dte.pe.raw <- DGEList(counts = catch.pe$counts,
                      genes = catch.pe$annotation,
                      samples = dt.targets.pe)
colnames(dte.pe.raw) <- dte.pe.raw$samples$Sample
```

```{r mouse_dte_pe_edger-rc_filtering}
keep.pe.raw <- 
  filterByExpr(dte.pe.raw) & dte.pe.raw$genes$GeneOfInterest
dte.pe.raw.filtr <- dte.pe.raw[keep.pe.raw,, keep.lib.sizes = FALSE]
```

```{r mouse_dte_pe_edger-rc_norm-disp}
dte.pe.raw.filtr <- calcNormFactors(dte.pe.raw.filtr)
dte.pe.raw.filtr <- estimateDisp(dte.pe.raw.filtr,design.pe,robust = TRUE)
```

```{r mouse_dte_pe_edger-rc_fit}
fit.pe.raw <- glmQLFit(dte.pe.raw.filtr,design.pe,robust = TRUE)

qlf.pe.LPvsB.raw <- glmQLFTest(fit.pe.raw,contrast = con.LPvsB)
qlf.pe.MLvsLP.raw <- glmQLFTest(fit.pe.raw,contrast = con.MLvsLP)

out.pe.LPvsB.raw <- topTags(qlf.pe.LPvsB.raw,n = Inf)
out.pe.MLvsLP.raw <- topTags(qlf.pe.MLvsLP.raw,n = Inf)

summary(decideTests(qlf.pe.LPvsB.raw))
summary(decideTests(qlf.pe.MLvsLP.raw))
```

#### sleuth-LRT

We now run `sleuth` with LRT.

```{r mouse_dte_pe_sleuth-lrt}
dt.targets.pe.sleuth <- dt.targets.pe[group %in% c('Basal','LP'),]
setnames(dt.targets.pe.sleuth,old = 'Sample',new = 'sample')

se.pe.sleuth.lrt <- 
  sleuth_prep(sample_to_covariates = dt.targets.pe.sleuth,full_model = ~ group)

se.pe.sleuth.lrt <- sleuth_fit(obj = se.pe.sleuth.lrt, fit_name = 'full')

se.pe.sleuth.lrt <- 
  sleuth_fit(obj = se.pe.sleuth.lrt,formula = ~ 1,fit_name = 'reduced')
se.pe.sleuth.lrt <- 
  sleuth_lrt(obj = se.pe.sleuth.lrt,null_model = 'reduced',alt_model = 'full')

out.pe.sleuth.lrt <- 
  sleuth_results(obj = se.pe.sleuth.lrt,
                 test = 'reduced:full', test_type = 'lrt',show_all = FALSE)
```

#### sleuth-Wald

We now run `sleuth` with Wald tests.

```{r mouse_dte_pe_sleuth-wald}
se.pe.sleuth.wald <- 
  sleuth_prep(sample_to_covariates = dt.targets.pe.sleuth,full_model = ~ group)

se.pe.sleuth.wald <- sleuth_fit(obj = se.pe.sleuth.wald, fit_name = 'full')

se.pe.sleuth.wald <- 
  sleuth_wt(obj = se.pe.sleuth.wald,which_beta = 'groupLP',which_model = 'full')

out.pe.sleuth.wald <- 
  sleuth_results(obj = se.pe.sleuth.wald, test = 'groupLP', test_type = 'wald',
                 show_all = FALSE)
```

#### Swish

Finally, we run `Swish`.

```{r mouse_dte_pe_swish}
dt.targets.pe.swish <- dt.targets.pe[group %in% c('Basal','LP'),]
dt.targets.pe.swish[,files := file.path(path,'quant.sf')]
dt.targets.pe.swish$group %<>% factor(levels = c('Basal','LP'))
setnames(dt.targets.pe.swish,old = 'Sample',new = 'names')

se.pe.swish <- tximeta(coldata = dt.targets.pe.swish,type = 'salmon')
se.pe.swish <- scaleInfReps(se.pe.swish)
se.pe.swish <- labelKeep(se.pe.swish)
se.pe.swish <- se.pe.swish[mcols(se.pe.swish)$keep,]
se.pe.swish <- swish(y = se.pe.swish, x = "group")
out.pe.swish <- as.data.frame(mcols(se.pe.swish))
```

## Differential gene expression

Now, we perform a gene-level analysis of the same data.

The function below computes estimates the mapping ambiguity overdispersion parameter at the level of gene-wise counts. It implements the exact same formula from `catchSalmon`, but it instead uses the aggregated counts at the gene-level from `tximport::summarizeToGene`.

```{r mouse_dge_pe_mao}
# Function computing catchSalmon's formula for gene-level counts
# To be used only for exploratory purposes
geneLevelCatchSalmon <- function(x) {
  NSamples <- ncol(x)
  NBoot <- sum(grepl('infRep', assayNames(x)))
  NTx <- nrow(x)
  DF <- rep_len(0L, NTx)
  OverDisp <- rep_len(0, NTx)
  
  for (i.samples in 1:NSamples) {
    Boot <- lapply(1:NBoot, function(i.boot) {
      assay(x, paste0('infRep', i.boot))[, i.samples]
    })
    Boot <- do.call(cbind, Boot)
    M <- rowMeans(Boot)
    i <- (M > 0)
    OverDisp[i] <- OverDisp[i] + rowSums((Boot[i,] - M[i]) ^ 2) / M[i]
    DF[i] <- DF[i] + NBoot - 1L
  }
  
  i <- (DF > 0L)
  OverDisp[i] <- OverDisp[i] / DF[i]
  DFMedian <- median(DF[i])
  DFPrior <- 3
  OverDispPrior <-
    median(OverDisp[i]) / qf(0.5, df1 = DFMedian, df2 = DFPrior)
  if (OverDispPrior < 1) {
    OverDispPrior <- 1
  }
  OverDisp[i] <-
    (DFPrior * OverDispPrior + DF[i] * OverDisp[i]) / (DFPrior + DF[i])
  OverDisp <- pmax(OverDisp, 1)
  OverDisp[!i] <- OverDispPrior
  rowData(x)$Overdispersion <- OverDisp
  return(x)
}
```

We summarize counts to the gene-level below and run the standard `edgeR` QL pipeline.

```{r mouse_dge_pe}
dt.targets.pe.tximeta <- dt.targets.pe
dt.targets.pe.tximeta[,files := file.path(path,'quant.sf')]
dt.targets.pe.tximeta$group %<>% factor(levels = c('Basal','LP','ML'))
setnames(dt.targets.pe.tximeta,old = 'Sample',new = 'names')

txm <- tximeta(coldata = dt.targets.pe.tximeta[,c('files','names')])
se.pe.gene <- summarizeToGene(txm)
se.pe.gene <- geneLevelCatchSalmon(se.pe.gene)

dge.pe <- DGEList(counts = assay(se.pe.gene,'counts'), 
                  samples = dt.targets.pe.tximeta,
                  genes = as.data.frame(rowData(se.pe.gene)))

key.dge.pe.anno.gene <- match(rownames(dge.pe),dt.anno.gene$GENEIDVERSION)

dge.pe$genes$GeneOfInterest <- dt.anno.gene$GeneOfInterest[key.dge.pe.anno.gene]
dge.pe$genes$NTranscriptPerGene <- dt.anno.gene$NTranscriptPerGene[key.dge.pe.anno.gene]
dge.pe$genes$GeneEntrezID <- dt.anno.gene$ENTREZID[key.dge.pe.anno.gene]
dge.pe$genes$GeneName <- dt.anno.gene$GENENAME[key.dge.pe.anno.gene]
dge.pe$genes$GeneType <- dt.anno.gene$GENEBIOTYPE[key.dge.pe.anno.gene]

keep.pe <- filterByExpr(dge.pe) & dge.pe$genes$GeneOfInterest

dge.pe.filtr <- dge.pe[keep.pe, , keep.lib.sizes = FALSE]
dge.pe.filtr <- calcNormFactors(dge.pe.filtr)

dge.pe.filtr <-
  estimateDisp(dge.pe.filtr, design = design.pe, robust = TRUE)

fit.pe <- glmQLFit(dge.pe.filtr,design.pe, robust = TRUE)

qlf.pe.LPvsB <- glmQLFTest(fit.pe,contrast = con.LPvsB)
qlf.pe.MLvsLP <- glmQLFTest(fit.pe,contrast = con.MLvsLP)

out.pe.LPvsB <- topTags(qlf.pe.LPvsB,n = Inf) 
out.pe.MLvsLP <- topTags(qlf.pe.MLvsLP,n = Inf) 

summary(decideTests(qlf.pe.LPvsB))
summary(decideTests(qlf.pe.MLvsLP))
```

## Plots and other exploratory analyses

Here we generate a few plots. We begin by assessing the mapping ambiguity overdispersion parameter of each transcript (y-axis) according the number of expressed transcripts associated with their parent gene (x-axis). This is Figure 1 of the main paper.

```{r mouse_eda_plots_mao,fig.height=5,fig.width=5}
dt.mao.plot <- as.data.table(dte.pe.scaled.filtr$genes)
dt.mao.plot[,NTranscriptPerGeneTrunc := ifelse(NTranscriptPerGene<10,NTranscriptPerGene,paste0('>=10'))]

dt.mao.plot$NTranscriptPerGeneTrunc %<>% factor(levels = paste0(c(1:10,'>=10')))

# Number of transcripts from single-transcript genes
dt.mao.plot[NTranscriptPerGene == 1,
            .(.N,sum(NTranscriptPerGene == 1 & Overdispersion>(1/0.9))/sum(NTranscriptPerGene == 1))]

# Number of transcripts from multi-transcript genes
dt.mao.plot[NTranscriptPerGene > 1,
            .(.N,sum(NTranscriptPerGene > 1 & Overdispersion>(1/0.9))/sum(NTranscriptPerGene > 1))]

# Number of transcripts from transcript-rich genes (#tx>10)
dt.mao.plot[NTranscriptPerGene >= 10,
            .(NGeneID = length(unique(GeneID)),
              NTranscriptID = .N,mean(Overdispersion))]

plot.mao.2 <- 
  ggplot(data = dt.mao.plot,aes(x = NTranscriptPerGeneTrunc,y = log10(Overdispersion))) +
  geom_boxplot(fill = '#bebebe',outlier.alpha = 0.2,col = 'black') +
  geom_smooth(aes(group = 1),color = '#ff0000',se = FALSE,span = 0.8,method = 'loess') +
  labs(x = 'Number of expressed transcripts per gene', y = 'Overdispersion (log10 scale)') +
  scale_y_continuous(limits = c(0,3),breaks = seq(0,3,0.5)) +
  theme_bw(base_size = 8,base_family = 'sans') +
  theme(panel.grid = element_blank(),
        axis.text = element_text(colour = 'black',size = 8))

agg_png(filename = file.path(path.misc,"figure1.png"),width = 5,height = 5,units = 'in',res = 300)
plot.mao.2
dev.off()

plot.mao.2
```

Then, we generate Figure 6 of the main paper below.

```{r mouse_eda_plots_dte,fig.height=9,fig.width=8}
# Heatmap of Foxp1 transcripts
cpm.scaled.filtr <- cpm(dte.pe.scaled.filtr,log = TRUE)
rownames(cpm.scaled.filtr) <- dte.pe.scaled.filtr$genes$TranscriptName

cpm.scaled.filtr.LPvsBasal <- 
  cpm.scaled.filtr[,grepl('Basal|LP',colnames(cpm.scaled.filtr))]

cpm.scaled.filtr.LPvsBasal <- t(scale(t(cpm.scaled.filtr.LPvsBasal)))

cpm.scaled.filtr.LPvsBasal.foxp1 <- 
  cpm.scaled.filtr.LPvsBasal[grepl('foxp1',rownames(cpm.scaled.filtr.LPvsBasal),ignore.case = TRUE),]

foo.heat <- function(x,cluster_rows = TRUE, fontsize = 8){
  tb <- data.table(TranscriptName = rownames(x),x)
  tb <- melt(tb,id.vars = 'TranscriptName',value.name = 'Expression')
  tb <- as_tibble(tb)
  
  tb %>%
    heatmap(.row = TranscriptName,.column = variable,.value = Expression,
            scale = 'none',palette_value = c("blue", "white", "red"),
            column_title = NULL,row_title = NULL,
            cluster_rows = cluster_rows,
            row_names_gp = gpar(fontsize = fontsize),
            column_names_gp = gpar(fontsize = fontsize),
            clustering_method_rows = "complete",
            clustering_method_columns = "complete",
            heatmap_legend_param = list(direction = "horizontal",
                                        at = seq(-3,3,1),
                                        title_position = 'topcenter',
                                        title_gp = gpar(fontsize = fontsize),
                                        labels_gp = gpar(fontsize = fontsize))) %>%
    as_ComplexHeatmap() %>%
    draw(heatmap_legend_side = "top")
}

plot.heat <- 
  wrap_elements(grid.grabExpr(draw(foo.heat(cpm.scaled.filtr.LPvsBasal.foxp1))))

# Heatmap of significant transcripts of non-significant breast cancer genes
tb.pe.LPvsB.scaled <- as.data.table(out.pe.LPvsB.scaled$table)
tb.pe.LPvsB <- as.data.table(out.pe.LPvsB$table)

tb.pe.LPvsB.scaled$FDR.Gene <- 
  tb.pe.LPvsB$FDR[match(tb.pe.LPvsB.scaled$GeneID,tb.pe.LPvsB$gene_id)]
tb.pe.LPvsB.scaled$logFC.Gene <- 
  tb.pe.LPvsB$logFC[match(tb.pe.LPvsB.scaled$GeneID,tb.pe.LPvsB$gene_id)]

interestGenes <- 
  tb.pe.LPvsB.scaled[FDR.Gene > 0.05 & 
                       FDR < 0.05 &
                       !is.na(GeneEntrezID),unique(GeneEntrezID)]

# Number of non-significant genes for which at least one of their transcripts is DE
length(interestGenes)

# Running KEGG analysis
tb.kegga <- kegga(interestGenes,species = 'Mm')
GK <- getGeneKEGGLinks(species.KEGG = "mmu")
tb.kegga['path:mmu05224',]

interestGenes.breast <- 
  interestGenes[interestGenes %in% GK$GeneID[GK$PathwayID == 'path:mmu05224']]

tb.pe.LPvsB.scaled.breast <- 
  tb.pe.LPvsB.scaled[tb.pe.LPvsB.scaled$GeneEntrezID %in% interestGenes.breast,]

tb.pe.LPvsB.scaled.breast <- 
  tb.pe.LPvsB.scaled.breast[tb.pe.LPvsB.scaled.breast$FDR < 0.05,]

cpm.scaled.filtr.LPvsBasal.breast <- 
  cpm.scaled.filtr.LPvsBasal[tb.pe.LPvsB.scaled.breast$TranscriptName,]

plot.heat.breast <- 
  wrap_elements(grid.grabExpr(draw(foo.heat(cpm.scaled.filtr.LPvsBasal.breast))))


# plotMD does not return invisible(), so we just use wrap_elements
foo.md <- function(x,fontsize = 8){
  par(mar = c(5, 4, 2, 2))
  plotMD(x,xlim = c(-2.5,17.5),
         main = NULL,cex = 0.5,legend = FALSE,
         cex.lab = fontsize/12,
         cex.axis = fontsize/12)
  legend('topright',
         legend = c('NotSig','Up','Down'),
         pch = rep(16,3), 
         col = c('black','red','blue'),
         cex = fontsize/12,
         pt.cex = c(0.3,0.5,0.5))
}
plot.md <- 
  wrap_elements(full = ~foo.md(qlf.pe.LPvsB.scaled))

# plotMDS returns invisible(), we need to manually export the plot (code from limma::plotMDS.MDS)
foo.mds <- function(x,fontsize = 8){
  obj.mds <- plotMDS(x,col = x$samples$Color,main = NULL)
  par(mar = c(5, 4, 2, 2))
  labels <- colnames(obj.mds$distance.matrix.squared)
  StringRadius <- 0.15 * 1 * nchar(labels)
  left.x <- obj.mds$x - StringRadius
  right.x <- obj.mds$x + StringRadius
  Perc <- round(obj.mds$var.explained * 100)
  xlab <- paste(obj.mds$axislabel, 1)
  ylab <- paste(obj.mds$axislabel, 2)
  xlab <- paste0(xlab, " (", Perc[1], "%)")
  ylab <- paste0(ylab, " (", Perc[2], "%)")
  
  plot(c(-6, 3), c(-3, 3),
       type = "n",xlab = xlab,ylab = ylab,
       cex.lab = fontsize/12,
       cex.axis = fontsize/12)
  text(obj.mds$x, obj.mds$y, labels = labels, cex = fontsize/12,col = x$samples$Color)
}
plot.mds <- wrap_elements(full = ~foo.mds(dte.pe.scaled.filtr))

plot.design <- c(area(1, 1),area(1,2),area(2, 1),area(2,2))

fig.heatmap <- wrap_plots(A = plot.mds,
                          B = plot.md,
                          C = plot.heat,
                          D = plot.heat.breast,
                          design = plot.design,
                          heights = c(0.4,0.6)) +
  plot_annotation(tag_levels = 'a') 

fig.heatmap <- fig.heatmap &
  theme(plot.tag = element_text(size = 8))

agg_png(filename = file.path(path.misc,"figure6.png"),width = 10,height = 10,units = 'in',res = 300)
fig.heatmap
dev.off()
```

Let's look at the results from the paired-end read data analysis for the `Foxp1-216` transcript.

```{r mouse_eda_foxp1}
# Foxp1-216
out.pe.LPvsB.scaled$table['ENSMUST00000175838.2',]
```

At the gene-level, we summarize some of the results from the DE analysis for the `Foxp1` gene.

```{r mouse_eda_table_foxp1}
tb.foxp1.gene <- 
  out.pe.LPvsB[grepl('ENSMUSG00000030067',out.pe.LPvsB$table$gene_id),]$table
tb.foxp1.gene <- data.frame(tb.foxp1.gene[,-c(2,3,4,5)],row.names = NULL)
setnames(tb.foxp1.gene,
         old = c('gene_id','GeneEntrezID','GeneName','GeneType'),
         new = c('Ensembl ID','Entrez ID','Name','Type'))

tb.foxp1.gene$Type <- gsub("_"," ",tb.foxp1.gene$Type)

tb.foxp1.gene$logFC <- formatC(round(tb.foxp1.gene$logFC,3),digits = 3,format = 'f')
tb.foxp1.gene$logCPM <- formatC(round(tb.foxp1.gene$logCPM,3),digits = 3,format = 'f')
tb.foxp1.gene$`F` <- formatC(round(tb.foxp1.gene$`F`,3),digits = 3,format = 'f')
tb.foxp1.gene$PValue <- formatC(tb.foxp1.gene$PValue,digits = 3,format = 'e')
tb.foxp1.gene$FDR <- formatC(tb.foxp1.gene$FDR,digits = 3,format = 'e')

tb.foxp1.gene$`Entrez ID` <- NULL
tb.foxp1.gene$Type <- NULL

kb.foxp1.gene <- 
  kbl(tb.foxp1.gene,
      escape = FALSE,
      format = 'latex',
      booktabs = TRUE,
      caption = paste('edgeR results from a DE analysis at the gene-level for',
                      'the Foxp1 gene comparing basal and LP cells using the',
                      'paired-end RNA-seq experiment of the epithelial cell',
                      'population of the mouse mammary gland'),
      align = 'llccccc') %>%
  kable_styling(font_size = 10)
save_kable(kb.foxp1.gene,file = file.path(path.misc,"supptable_foxp1.tex"))
```

We can also compare the distribution of the overdispersion estimates between gene- and transcript-level analyses.

```{r mouse_eda_plots_mao_gene}
## Gene-level
df.output.gene <- 
  as.data.table(dge.pe$genes[,c('GeneName','GeneEntrezID','GeneType','Overdispersion')])
setnames(df.output.gene,
         old = c('GeneName','GeneEntrezID','GeneType','Overdispersion'),
         new = c('Symbol','EntrezID','Type','Overdispersion'))
df.output.gene[,Level := 'Gene']

## Transcript-level
df.output.tx <- data.table(Symbol = catch.pe$annotation$TranscriptName,
                           EntrezID = catch.pe$annotation$GeneEntrezID,
                           Type = catch.pe$annotation$Type,
                           Overdispersion = catch.pe$annotation$Overdispersion,
                           Level = 'Transcript')


df.output.gene.tx <- rbindlist(list(df.output.gene,
                                    df.output.tx))

fig.mao.gene.tx <- ggplot(df.output.gene.tx,aes(x = log10(Overdispersion),y = Level,fill = Level)) +
  geom_boxplot(outlier.alpha = 0.25,fill = "#bebebe",col = 'black') +
  labs(y = NULL,x = 'Mapping ambiguity overdispersion (log10 scale)') +
  theme_bw(base_size = 8,base_family = 'sans') +
  theme(legend.position = 'none',
        panel.grid = element_blank(),
        axis.text = element_text(colour = 'black',size = 8))

agg_png(filename = file.path(path.misc,"suppfigure_overdispersion.png"),width = 7.5,height = 5,units = 'in',res = 300)
fig.mao.gene.tx
dev.off()

fig.mao.gene.tx
```

Below we have the top 100 genes with largest mapping ambiguity overdispersion.

```{r mouse_eda_table_mao}
df.output.gene.top <- df.output.gene[order(-Overdispersion),][1:100,]
df.output.gene.top[,Level := NULL]
df.output.gene.top$Type <- 
  gsub("_"," ",df.output.gene.top$Type)
df.output.gene.top$EntrezID[is.na(df.output.gene.top$EntrezID)] <- 
  "-"

cap.mao <- paste("Top 100 genes with largest mapping ambiguity overdispersion.",
                 "Data from the RNA-seq experiment of the epithelial cell",
                 "population from the mouse mammary gland generated with",
                 "paired-end reads.")

kb.output.gene.top <- kbl(df.output.gene.top,
                          longtable = TRUE,
                          escape = FALSE,
                          format = 'latex',
                          booktabs = TRUE,
                          caption = cap.mao,
                          digits = 2,
                          align = c('l',rep('r',3)),
                          col.names = c('Gene Symbol','Entrez ID','Biotype','Overdispersion')) %>%
  kable_styling(latex_options = c("scale_down","repeat_header"),font_size = 10)
save_kable(kb.output.gene.top,file = file.path(path.misc,"supptable_overdispersion.tex"))
```

# Analysis of single-end data

Now, we present a similar analysis but using the single-end read experiment from the same population of epithelial cells of the mouse mammay gland.

## Transcript-level analysis

### Data wrangling

We again begin with some data wrangling.

```{r mouse_data_se_targets}
dt.targets.se <- fread(file.path(path.data.se,'misc/targets.txt'))
dt.targets.se[,Sample := paste(Group,Replicate,sep = '.')]
dt.targets.se[,Population := mapvalues(Population,'Luminal','LP')]
dt.targets.se$Stage <- strsplit2(dt.targets.se$Group,"\\.")[,2]
dt.targets.se$Group <- NULL

dt.targets.se[,Color := 
                mapvalues(Population,from = c('Basal','LP'),to = c('blue','darkgreen'))]

dt.targets.se[,path := file.path(path.quant.se,'salmon',gsub('.fastq.gz','',File))]
```

And then we load the output from `Salmon` into our R session with the function `catchSalmon`.

```{r mouse_data_se_catch}
catch.se <- catchSalmon(dt.targets.se$path,verbose = FALSE)

key.catch.se.anno <- match(rownames(catch.se$annotation),dt.anno$TXIDVERSION)

catch.se$annotation$TranscriptName <- dt.anno$TXEXTERNALNAME[key.catch.se.anno]
catch.se$annotation$GeneID <- dt.anno$GENEIDVERSION[key.catch.se.anno]
catch.se$annotation$GeneName <- dt.anno$GENENAME[key.catch.se.anno]
catch.se$annotation$GeneEntrezID <- dt.anno$ENTREZID[key.catch.se.anno]
catch.se$annotation$GeneOfInterest <- dt.anno$GeneOfInterest[key.catch.se.anno]
catch.se$annotation$NTranscriptPerGene <- dt.anno$NTranscriptPerGene[key.catch.se.anno]
```

### Differential transcript expression

In this analysis we only run `edgeR`. We again compare scaled and raw counts.

#### edgeR with count scaling

We create the `DGEList` object using scaled counts.

```{r mouse_dte_se_edger-cs}
dte.se.scaled <- 
  DGEList(counts = catch.se$counts/catch.se$annotation$Overdispersion,
          genes = catch.se$annotation,
          samples = dt.targets.se)
colnames(dte.se.scaled) <- dte.se.scaled$samples$Sample
```

Perform some filtering:

```{r mouse_dte_se_edger-cs_filtering}
keep.se.scaled <- 
  filterByExpr(dte.se.scaled,group = dte.se.scaled$samples$Population) & 
  dte.se.scaled$genes$GeneOfInterest
dte.se.scaled.filtr <- dte.se.scaled[keep.se.scaled,, keep.lib.sizes = FALSE]
```

Calculate normalization factors, estimate the trended negative binomial dispersions and perform the QL pipeline:

```{r mouse_dte_se_edger-cs_norm-disp}
design.se <- model.matrix(~Stage + Population,data = dte.se.scaled.filtr$samples)
dte.se.scaled.filtr <- calcNormFactors(dte.se.scaled.filtr)
dte.se.scaled.filtr <- estimateDisp(dte.se.scaled.filtr,design.se,robust = TRUE)
```

```{r mouse_dte_se_edger-cs_fit}
fit.se.scaled <- glmQLFit(dte.se.scaled.filtr,design.se,robust = TRUE)

qlf.se.LPvsB.scaled <- glmQLFTest(fit.se.scaled)

out.se.LPvsB.scaled <- topTags(qlf.se.LPvsB.scaled,n = Inf)

summary(decideTests(qlf.se.LPvsB.scaled))
```

#### edgeR with raw counts

We repeat the same analysis using raw counts:

```{r mouse_dte_se_edger-rc}
dte.se.raw <- 
  DGEList(counts = catch.se$counts,
          genes = catch.se$annotation,
          samples = dt.targets.se)
colnames(dte.se.raw) <- dte.se.raw$samples$Sample
```

```{r mouse_dte_se_edger-rc_filtering}
keep.se.raw <- 
  filterByExpr(dte.se.raw,group = dte.se.raw$samples$Population) & 
  dte.se.raw$genes$GeneOfInterest
dte.se.raw.filtr <- dte.se.raw[keep.se.raw,,keep.lib.sizes = FALSE]
```

```{r mouse_dte_se_edger-rc_norm-disp}
dte.se.raw.filtr <- calcNormFactors(dte.se.raw.filtr)
dte.se.raw.filtr <- estimateDisp(dte.se.raw.filtr,design.se,robust = TRUE)
```

```{r mouse_dte_se_edger-rc_fit}
fit.se.raw <- glmQLFit(dte.se.raw.filtr,design.se,robust = TRUE)

qlf.se.LPvsB.raw <- glmQLFTest(fit.se.raw)

out.se.LPvsB.raw <- topTags(qlf.se.LPvsB.raw,n = Inf)

summary(decideTests(qlf.se.LPvsB.raw))
```

## Plots and other exploratory analyses

Below is a MA plot from the DTE results using single-end scaled data.

```{r mouse_eda_se_dte}
agg_png(filename = file.path(path.misc,"suppfigure_maplot.png"),width = 6,height = 6,units = 'in',res = 300)
plotMD(qlf.se.LPvsB.scaled,xlim = c(-1.5,17.5),
       main = NULL,cex = 0.5,legend = FALSE,
       cex.lab = 8/12,
       cex.axis = 8/12)
legend('topright',
       legend = c('NotSig','Up','Down'),
       pch = rep(16,3), 
       col = c('black','red','blue'),
       cex = 8/12,
       pt.cex = c(0.3,0.5,0.5))
dev.off()
```

And we tabulate the results from the analysis using single-end scaled counts for the Foxp1 gene.

```{r r mouse_eda_se_dte_foxp1}
# Foxp1 transcripts (EntrezID 108655)
out.se.LPvsB.scaled$table[out.se.LPvsB.scaled$table$GeneEntrezID %in% '108655',]
out.se.LPvsB.raw$table[out.se.LPvsB.raw$table$GeneEntrezID %in% '108655',]

tb.se.foxp1.gene <- 
  out.se.LPvsB.scaled[grepl('ENSMUSG00000030067',out.se.LPvsB.scaled$table$GeneID),]$table
tb.se.foxp1.gene <- data.frame("Ensembl ID" = rownames(tb.se.foxp1.gene),
                               tb.se.foxp1.gene[,-c(1,2,3,5,6,7,8,9)],row.names = NULL)

setnames(tb.se.foxp1.gene,
         old = c('Ensembl.ID','TranscriptName'),
         new = c('Ensembl ID','Name'))

tb.se.foxp1.gene$logFC <- formatC(round(tb.se.foxp1.gene$logFC,3),digits = 3,format = 'f')
tb.se.foxp1.gene$logCPM <- formatC(round(tb.se.foxp1.gene$logCPM,3),digits = 3,format = 'f')
tb.se.foxp1.gene$`F` <- formatC(round(tb.se.foxp1.gene$`F`,3),digits = 3,format = 'f')
tb.se.foxp1.gene$PValue <- formatC(tb.se.foxp1.gene$PValue,digits = 3,format = 'e')
tb.se.foxp1.gene$FDR <- formatC(tb.se.foxp1.gene$FDR,digits = 3,format = 'e')

kb.se.foxp1.gene <- 
  kbl(tb.se.foxp1.gene,
      escape = FALSE,
      format = 'latex',
      booktabs = TRUE,
      caption = paste("edgeR results with count scaling from DTE analysis",
                      "comparing basal and LP cells for the single-end RNA-seq",
                      "experiment of the epithelia cell population from the",
                      "mouse mammary gland. Shown are the topTags results",
                      "restricted to the Foxp1 transcripts."),
      align = "llccccc") %>%
  kable_styling(font_size = 10)
save_kable(kb.se.foxp1.gene,file = file.path(path.misc,"supptable_singleend.tex"))
```
